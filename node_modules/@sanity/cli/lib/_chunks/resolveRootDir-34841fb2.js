'use strict';

var require$$0$1 = require('url');
var require$$2 = require('events');
var require$$2$1 = require('https');
var require$$3$1 = require('http');
var require$$0 = require('util');
var require$$0$3 = require('get-it');
var require$$2$3 = require('get-it/lib/middleware/observable');
var require$$3$2 = require('get-it/lib/middleware/jsonRequest');
var require$$4 = require('get-it/lib/middleware/jsonResponse');
var require$$5 = require('get-it/lib/middleware/progress');
var require$$0$2 = require('get-it/lib-node/middleware/retry');
var require$$1 = require('get-it/lib-node/middleware/debug');
var require$$2$2 = require('get-it/lib-node/middleware/headers');
var path = require('path');
var require$$0$6 = require('fs');
var require$$0$4 = require('tty');
var require$$0$5 = require('os');
function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$2__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);
var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3$1);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
var require$$2__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$2$3);
var require$$3__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$3$2);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5);
var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$2__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$2$2);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var require$$0__default$6 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
var require$$0__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);
var require$$0__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
function getAugmentedNamespace(n) {
  var f = n.default;
  if (typeof f == "function") {
    var a = function () {
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {
    value: true
  });
  Object.keys(n).forEach(function (k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function () {
        return n[k];
      }
    });
  });
  return a;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }

    // Detect buggy property enumeration order in older V8 versions.

    // https://bugs.chromium.org/p/v8/issues/detail?id=4118
    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
    test1[5] = 'de';
    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    }

    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });
    if (order2.join('') !== '0123456789') {
      return false;
    }

    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }
    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
var Observable$5 = {};
var canReportError$1 = {};
var Subscriber$1 = {};
var isFunction$1 = {};
Object.defineProperty(isFunction$1, "__esModule", {
  value: true
});
function isFunction(x) {
  return typeof x === 'function';
}
isFunction$1.isFunction = isFunction;
var Observer = {};
var config$1 = {};
Object.defineProperty(config$1, "__esModule", {
  value: true
});
var _enable_super_gross_mode_that_will_cause_bad_things = false;
config$1.config = {
  Promise: undefined,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = new Error();
      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
      console.log('RxJS: Back to a better error behavior. Thank you. <3');
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
var hostReportError$1 = {};
Object.defineProperty(hostReportError$1, "__esModule", {
  value: true
});
function hostReportError(err) {
  setTimeout(function () {
    throw err;
  }, 0);
}
hostReportError$1.hostReportError = hostReportError;
Object.defineProperty(Observer, "__esModule", {
  value: true
});
var config_1$2 = config$1;
var hostReportError_1$1 = hostReportError$1;
Observer.empty = {
  closed: true,
  next: function (value) {},
  error: function (err) {
    if (config_1$2.config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError_1$1.hostReportError(err);
    }
  },
  complete: function () {}
};
var Subscription$1 = {};
var isArray = {};
Object.defineProperty(isArray, "__esModule", {
  value: true
});
isArray.isArray = function () {
  return Array.isArray || function (x) {
    return x && typeof x.length === 'number';
  };
}();
var isObject$1 = {};
Object.defineProperty(isObject$1, "__esModule", {
  value: true
});
function isObject(x) {
  return x !== null && typeof x === 'object';
}
isObject$1.isObject = isObject;
var UnsubscriptionError = {};
Object.defineProperty(UnsubscriptionError, "__esModule", {
  value: true
});
var UnsubscriptionErrorImpl = function () {
  function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
      return i + 1 + ") " + err.toString();
    }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
  }
  UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
  return UnsubscriptionErrorImpl;
}();
UnsubscriptionError.UnsubscriptionError = UnsubscriptionErrorImpl;
Object.defineProperty(Subscription$1, "__esModule", {
  value: true
});
var isArray_1 = isArray;
var isObject_1 = isObject$1;
var isFunction_1$1 = isFunction$1;
var UnsubscriptionError_1 = UnsubscriptionError;
var Subscription = function () {
  function Subscription(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe;
    }
  }
  Subscription.prototype.unsubscribe = function () {
    var errors;
    if (this.closed) {
      return;
    }
    var _a = this,
      _parentOrParents = _a._parentOrParents,
      _ctorUnsubscribe = _a._ctorUnsubscribe,
      _unsubscribe = _a._unsubscribe,
      _subscriptions = _a._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index = 0; index < _parentOrParents.length; ++index) {
        var parent_1 = _parentOrParents[index];
        parent_1.remove(this);
      }
    }
    if (isFunction_1$1.isFunction(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = undefined;
      }
      try {
        _unsubscribe.call(this);
      } catch (e) {
        errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }
    if (isArray_1.isArray(_subscriptions)) {
      var index = -1;
      var len = _subscriptions.length;
      while (++index < len) {
        var sub = _subscriptions[index];
        if (isObject_1.isObject(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            errors = errors || [];
            if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }
    if (errors) {
      throw new UnsubscriptionError_1.UnsubscriptionError(errors);
    }
  };
  Subscription.prototype.add = function (teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription.EMPTY;
    }
    switch (typeof teardown) {
      case 'function':
        subscription = new Subscription(teardown);
      case 'object':
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription)) {
          var tmp = subscription;
          subscription = new Subscription();
          subscription._subscriptions = [tmp];
        }
        break;
      default:
        {
          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  };
  Subscription.prototype.remove = function (subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription.EMPTY = function (empty) {
    empty.closed = true;
    return empty;
  }(new Subscription());
  return Subscription;
}();
Subscription$1.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function (errs, err) {
    return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = {};
(function (exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.rxSubscriber = function () {
    return typeof Symbol === 'function' ? Symbol('rxSubscriber') : '@@rxSubscriber_' + Math.random();
  }();
  exports.$$rxSubscriber = exports.rxSubscriber;
})(rxSubscriber);
var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return extendStatics(d, b);
  };
  return function (d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(Subscriber$1, "__esModule", {
  value: true
});
var isFunction_1 = isFunction$1;
var Observer_1$1 = Observer;
var Subscription_1 = Subscription$1;
var rxSubscriber_1$1 = rxSubscriber;
var config_1$1 = config$1;
var hostReportError_1 = hostReportError$1;
var Subscriber = function (_super) {
  __extends$2(Subscriber, _super);
  function Subscriber(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = Observer_1$1.empty;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = Observer_1$1.empty;
          break;
        }
        if (typeof destinationOrNext === 'object') {
          if (destinationOrNext instanceof Subscriber) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber.prototype[rxSubscriber_1$1.rxSubscriber] = function () {
    return this;
  };
  Subscriber.create = function (next, error, complete) {
    var subscriber = new Subscriber(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber.prototype.next = function (value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber.prototype.complete = function () {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber.prototype.unsubscribe = function () {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber.prototype._next = function (value) {
    this.destination.next(value);
  };
  Subscriber.prototype._error = function (err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber.prototype._complete = function () {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber.prototype._unsubscribeAndRecycle = function () {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber;
}(Subscription_1.Subscription);
Subscriber$1.Subscriber = Subscriber;
var SafeSubscriber = function (_super) {
  __extends$2(SafeSubscriber, _super);
  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;
    if (isFunction_1.isFunction(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== Observer_1$1.empty) {
        context = Object.create(observerOrNext);
        if (isFunction_1.isFunction(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber.prototype.next = function (value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config_1$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config_1$1.config.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError_1.hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError_1.hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber.prototype.complete = function () {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function () {
          return _this._complete.call(_this._context);
        };
        if (!config_1$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config_1$1.config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError_1.hostReportError(err);
      }
    }
  };
  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
    if (!config_1$1.config.useDeprecatedSynchronousErrorHandling) {
      throw new Error('bad call');
    }
    try {
      fn.call(this._context, value);
    } catch (err) {
      if (config_1$1.config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        hostReportError_1.hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber.prototype._unsubscribe = function () {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber;
}(Subscriber);
Subscriber$1.SafeSubscriber = SafeSubscriber;
Object.defineProperty(canReportError$1, "__esModule", {
  value: true
});
var Subscriber_1$3 = Subscriber$1;
function canReportError(observer) {
  while (observer) {
    var _a = observer,
      closed_1 = _a.closed,
      destination = _a.destination,
      isStopped = _a.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber_1$3.Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
canReportError$1.canReportError = canReportError;
var toSubscriber$1 = {};
Object.defineProperty(toSubscriber$1, "__esModule", {
  value: true
});
var Subscriber_1$2 = Subscriber$1;
var rxSubscriber_1 = rxSubscriber;
var Observer_1 = Observer;
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber_1$2.Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
      return nextOrObserver[rxSubscriber_1.rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber_1$2.Subscriber(Observer_1.empty);
  }
  return new Subscriber_1$2.Subscriber(nextOrObserver, error, complete);
}
toSubscriber$1.toSubscriber = toSubscriber;
var observable$2 = {};
Object.defineProperty(observable$2, "__esModule", {
  value: true
});
observable$2.observable = function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}();
var pipe$1 = {};
var identity$1 = {};
Object.defineProperty(identity$1, "__esModule", {
  value: true
});
function identity(x) {
  return x;
}
identity$1.identity = identity;
Object.defineProperty(pipe$1, "__esModule", {
  value: true
});
var identity_1 = identity$1;
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
pipe$1.pipe = pipe;
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity_1.identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function (prev, fn) {
      return fn(prev);
    }, input);
  };
}
pipe$1.pipeFromArray = pipeFromArray;
Object.defineProperty(Observable$5, "__esModule", {
  value: true
});
var canReportError_1 = canReportError$1;
var toSubscriber_1 = toSubscriber$1;
var observable_1 = observable$2;
var pipe_1 = pipe$1;
var config_1 = config$1;
var Observable$4 = function () {
  function Observable(subscribe) {
    this._isScalar = false;
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable.prototype.lift = function (operator) {
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  };
  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable.prototype._trySubscribe = function (sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError_1.canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable.prototype.forEach = function (next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function (value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };
  Observable.prototype._subscribe = function (subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };
  Observable.prototype[observable_1.observable] = function () {
    return this;
  };
  Observable.prototype.pipe = function () {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipe_1.pipeFromArray(operations)(this);
  };
  Observable.prototype.toPromise = function (promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var value;
      _this.subscribe(function (x) {
        return value = x;
      }, function (err) {
        return reject(err);
      }, function () {
        return resolve(value);
      });
    });
  };
  Observable.create = function (subscribe) {
    return new Observable(subscribe);
  };
  return Observable;
}();
Observable$5.Observable = Observable$4;
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config_1.config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error('no Promise impl found');
  }
  return promiseCtor;
}
var filter$5 = {};
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return extendStatics(d, b);
  };
  return function (d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(filter$5, "__esModule", {
  value: true
});
var Subscriber_1$1 = Subscriber$1;
function filter$4(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
filter$5.filter = filter$4;
var FilterOperator = function () {
  function FilterOperator(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  FilterOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };
  return FilterOperator;
}();
var FilterSubscriber = function (_super) {
  __extends$1(FilterSubscriber, _super);
  function FilterSubscriber(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }
  FilterSubscriber.prototype._next = function (value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value);
    }
  };
  return FilterSubscriber;
}(Subscriber_1$1.Subscriber);
var map$5 = {};
var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return extendStatics(d, b);
  };
  return function (d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(map$5, "__esModule", {
  value: true
});
var Subscriber_1 = Subscriber$1;
function map$4(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== 'function') {
      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
map$5.map = map$4;
var MapOperator = function () {
  function MapOperator(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator;
}();
map$5.MapOperator = MapOperator;
var MapSubscriber = function (_super) {
  __extends(MapSubscriber, _super);
  function MapSubscriber(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber.prototype._next = function (value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber;
}(Subscriber_1.Subscriber);

//  Since `@sanity/client` doesn't offer ESM exports (yet) const {filter} = require('rxjs/operators') will cause the the whole of rxjs to be included in the bundle.
//  The internal import paths here is a stop-gap measure and will become less of a problem when @sanity/client export tree-shakeable esm bundles
var _require$5 = Observable$5,
  Observable$3 = _require$5.Observable;
var _require2$2 = filter$5,
  filter$3 = _require2$2.filter;
var _require3 = map$5,
  map$3 = _require3.map;
var observable$1 = {
  Observable: Observable$3,
  filter: filter$3,
  map: map$3
};
var getSelection$2 = function getSelection(sel) {
  if (typeof sel === 'string' || Array.isArray(sel)) {
    return {
      id: sel
    };
  }
  if (sel && sel.query) {
    return 'params' in sel ? {
      query: sel.query,
      params: sel.params
    } : {
      query: sel.query
    };
  }
  var selectionOpts = ['* Document ID (<docId>)', '* Array of document IDs', '* Object containing `query`'].join('\n');
  throw new Error("Unknown selection - must be one of:\n\n".concat(selectionOpts));
};
var validators$3 = {};
(function (exports) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  var VALID_ASSET_TYPES = ['image', 'file'];
  var VALID_INSERT_LOCATIONS = ['before', 'after', 'replace'];
  exports.dataset = function (name) {
    if (!/^(~[a-z0-9]{1}[-\w]{0,63}|[a-z0-9]{1}[-\w]{0,63})$/.test(name)) {
      throw new Error('Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters');
    }
  };
  exports.projectId = function (id) {
    if (!/^[-a-z0-9]+$/i.test(id)) {
      throw new Error('`projectId` can only contain only a-z, 0-9 and dashes');
    }
  };
  exports.validateAssetType = function (type) {
    if (VALID_ASSET_TYPES.indexOf(type) === -1) {
      throw new Error("Invalid asset type: ".concat(type, ". Must be one of ").concat(VALID_ASSET_TYPES.join(', ')));
    }
  };
  exports.validateObject = function (op, val) {
    if (val === null || _typeof(val) !== 'object' || Array.isArray(val)) {
      throw new Error("".concat(op, "() takes an object of properties"));
    }
  };
  exports.requireDocumentId = function (op, doc) {
    if (!doc._id) {
      throw new Error("".concat(op, "() requires that the document contains an ID (\"_id\" property)"));
    }
    exports.validateDocumentId(op, doc._id);
  };
  exports.validateDocumentId = function (op, id) {
    if (typeof id !== 'string' || !/^[a-z0-9_.-]+$/i.test(id)) {
      throw new Error("".concat(op, "(): \"").concat(id, "\" is not a valid document ID"));
    }
  };
  exports.validateInsert = function (at, selector, items) {
    var signature = 'insert(at, selector, items)';
    if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
      var valid = VALID_INSERT_LOCATIONS.map(function (loc) {
        return "\"".concat(loc, "\"");
      }).join(', ');
      throw new Error("".concat(signature, " takes an \"at\"-argument which is one of: ").concat(valid));
    }
    if (typeof selector !== 'string') {
      throw new Error("".concat(signature, " takes a \"selector\"-argument which must be a string"));
    }
    if (!Array.isArray(items)) {
      throw new Error("".concat(signature, " takes an \"items\"-argument which must be an array"));
    }
  };
  exports.hasDataset = function (config) {
    if (!config.dataset) {
      throw new Error('`dataset` must be provided to perform queries');
    }
    return config.dataset || '';
  };
  exports.requestTag = function (tag) {
    if (typeof tag !== 'string' || !/^[a-z0-9._-]{1,75}$/i.test(tag)) {
      throw new Error("Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.");
    }
    return tag;
  };
})(validators$3);
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var assign$c = objectAssign;
var getSelection$1 = getSelection$2;
var validate$2 = validators$3;
var validateObject = validate$2.validateObject;
var validateInsert = validate$2.validateInsert;
function Patch$3(selection) {
  var operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var client = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  this.selection = selection;
  this.operations = assign$c({}, operations);
  this.client = client;
}
assign$c(Patch$3.prototype, {
  clone: function clone() {
    return new Patch$3(this.selection, assign$c({}, this.operations), this.client);
  },
  set: function set(props) {
    return this._assign('set', props);
  },
  diffMatchPatch: function diffMatchPatch(props) {
    validateObject('diffMatchPatch', props);
    return this._assign('diffMatchPatch', props);
  },
  unset: function unset(attrs) {
    if (!Array.isArray(attrs)) {
      throw new Error('unset(attrs) takes an array of attributes to unset, non-array given');
    }
    this.operations = assign$c({}, this.operations, {
      unset: attrs
    });
    return this;
  },
  setIfMissing: function setIfMissing(props) {
    return this._assign('setIfMissing', props);
  },
  replace: function replace(props) {
    validateObject('replace', props);
    return this._set('set', {
      $: props
    }); // eslint-disable-line id-length
  },

  inc: function inc(props) {
    return this._assign('inc', props);
  },
  dec: function dec(props) {
    return this._assign('dec', props);
  },
  insert: function insert(at, selector, items) {
    var _this$_assign;
    validateInsert(at, selector, items);
    return this._assign('insert', (_this$_assign = {}, _defineProperty$4(_this$_assign, at, selector), _defineProperty$4(_this$_assign, "items", items), _this$_assign));
  },
  append: function append(selector, items) {
    return this.insert('after', "".concat(selector, "[-1]"), items);
  },
  prepend: function prepend(selector, items) {
    return this.insert('before', "".concat(selector, "[0]"), items);
  },
  splice: function splice(selector, start, deleteCount, items) {
    // Negative indexes doesn't mean the same in Sanity as they do in JS;
    // -1 means "actually at the end of the array", which allows inserting
    // at the end of the array without knowing its length. We therefore have
    // to substract negative indexes by one to match JS. If you want Sanity-
    // behaviour, just use `insert('replace', selector, items)` directly
    var delAll = typeof deleteCount === 'undefined' || deleteCount === -1;
    var startIndex = start < 0 ? start - 1 : start;
    var delCount = delAll ? -1 : Math.max(0, start + deleteCount);
    var delRange = startIndex < 0 && delCount >= 0 ? '' : delCount;
    var rangeSelector = "".concat(selector, "[").concat(startIndex, ":").concat(delRange, "]");
    return this.insert('replace', rangeSelector, items || []);
  },
  ifRevisionId: function ifRevisionId(rev) {
    this.operations.ifRevisionID = rev;
    return this;
  },
  serialize: function serialize() {
    return assign$c(getSelection$1(this.selection), this.operations);
  },
  toJSON: function toJSON() {
    return this.serialize();
  },
  commit: function commit() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.client) {
      throw new Error('No `client` passed to patch, either provide one or pass the ' + 'patch to a clients `mutate()` method');
    }
    var returnFirst = typeof this.selection === 'string';
    var opts = assign$c({
      returnFirst: returnFirst,
      returnDocuments: true
    }, options);
    return this.client.mutate({
      patch: this.serialize()
    }, opts);
  },
  reset: function reset() {
    this.operations = {};
    return this;
  },
  _set: function _set(op, props) {
    return this._assign(op, props, false);
  },
  _assign: function _assign(op, props) {
    var merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    validateObject(op, props);
    this.operations = assign$c({}, this.operations, _defineProperty$4({}, op, assign$c({}, merge && this.operations[op] || {}, props)));
    return this;
  }
});
var patch = Patch$3;
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var assign$b = objectAssign;
var validators$2 = validators$3;
var Patch$2 = patch;
var defaultMutateOptions = {
  returnDocuments: false
};
function Transaction$2() {
  var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var client = arguments.length > 1 ? arguments[1] : undefined;
  var transactionId = arguments.length > 2 ? arguments[2] : undefined;
  this.trxId = transactionId;
  this.operations = operations;
  this.client = client;
}
assign$b(Transaction$2.prototype, {
  clone: function clone() {
    return new Transaction$2(this.operations.slice(0), this.client, this.trxId);
  },
  create: function create(doc) {
    validators$2.validateObject('create', doc);
    return this._add({
      create: doc
    });
  },
  createIfNotExists: function createIfNotExists(doc) {
    var op = 'createIfNotExists';
    validators$2.validateObject(op, doc);
    validators$2.requireDocumentId(op, doc);
    return this._add(_defineProperty$3({}, op, doc));
  },
  createOrReplace: function createOrReplace(doc) {
    var op = 'createOrReplace';
    validators$2.validateObject(op, doc);
    validators$2.requireDocumentId(op, doc);
    return this._add(_defineProperty$3({}, op, doc));
  },
  delete: function _delete(documentId) {
    validators$2.validateDocumentId('delete', documentId);
    return this._add({
      delete: {
        id: documentId
      }
    });
  },
  patch: function patch(documentId, patchOps) {
    var isBuilder = typeof patchOps === 'function';
    var isPatch = documentId instanceof Patch$2; // transaction.patch(client.patch('documentId').inc({visits: 1}))

    if (isPatch) {
      return this._add({
        patch: documentId.serialize()
      });
    } // patch => patch.inc({visits: 1}).set({foo: 'bar'})

    if (isBuilder) {
      var patch = patchOps(new Patch$2(documentId, {}, this.client));
      if (!(patch instanceof Patch$2)) {
        throw new Error('function passed to `patch()` must return the patch');
      }
      return this._add({
        patch: patch.serialize()
      });
    }
    return this._add({
      patch: assign$b({
        id: documentId
      }, patchOps)
    });
  },
  transactionId: function transactionId(id) {
    if (!id) {
      return this.trxId;
    }
    this.trxId = id;
    return this;
  },
  serialize: function serialize() {
    return this.operations.slice();
  },
  toJSON: function toJSON() {
    return this.serialize();
  },
  commit: function commit(options) {
    if (!this.client) {
      throw new Error('No `client` passed to transaction, either provide one or pass the ' + 'transaction to a clients `mutate()` method');
    }
    return this.client.mutate(this.serialize(), assign$b({
      transactionId: this.trxId
    }, defaultMutateOptions, options || {}));
  },
  reset: function reset() {
    this.operations = [];
    return this;
  },
  _add: function _add(mut) {
    this.operations.push(mut);
    return this;
  }
});
var transaction = Transaction$2;
var _excluded = ["tag"];
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var enc = encodeURIComponent;
var encodeQueryString$2 = function (_ref) {
  var query = _ref.query,
    _ref$params = _ref.params,
    params = _ref$params === void 0 ? {} : _ref$params,
    _ref$options = _ref.options,
    options = _ref$options === void 0 ? {} : _ref$options;

  // We generally want tag at the start of the query string
  var tag = options.tag,
    opts = _objectWithoutProperties(options, _excluded);
  var q = "query=".concat(enc(query));
  var base = tag ? "?tag=".concat(enc(tag), "&").concat(q) : "?".concat(q);
  var qString = Object.keys(params).reduce(function (qs, param) {
    return "".concat(qs, "&").concat(enc("$".concat(param)), "=").concat(enc(JSON.stringify(params[param])));
  }, base);
  return Object.keys(opts).reduce(function (qs, option) {
    // Only include the option if it is truthy
    return options[option] ? "".concat(qs, "&").concat(enc(option), "=").concat(enc(options[option])) : qs;
  }, qString);
};
var node$1 = {
  exports: {}
};
var parse = require$$0__default$1["default"].parse;
var events = require$$2__default["default"];
var https = require$$2__default$1["default"];
var http = require$$3__default["default"];
var util = require$$0__default["default"];
var httpsOptions = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'rejectUnauthorized', 'secureProtocol', 'servername', 'checkServerIdentity'];
var bom = [239, 187, 191];
var colon = 58;
var space = 32;
var lineFeed = 10;
var carriageReturn = 13;
// Beyond 256KB we could not observe any gain in performance
var maxBufferAheadAllocation = 1024 * 256;
// Headers matching the pattern should be removed when redirecting to different origin
var reUnsafeHeader = /^(cookie|authorization)$/i;
function hasBom(buf) {
  return bom.every(function (charCode, index) {
    return buf[index] === charCode;
  });
}

/**
 * Creates a new EventSource object
 *
 * @param {String} url the URL to which to connect
 * @param {Object} [eventSourceInitDict] extra init params. See README for details.
 * @api public
 **/
function EventSource$1(url, eventSourceInitDict) {
  var readyState = EventSource$1.CONNECTING;
  var headers = eventSourceInitDict && eventSourceInitDict.headers;
  var hasNewOrigin = false;
  Object.defineProperty(this, 'readyState', {
    get: function () {
      return readyState;
    }
  });
  Object.defineProperty(this, 'url', {
    get: function () {
      return url;
    }
  });
  var self = this;
  self.reconnectInterval = 1000;
  self.connectionInProgress = false;
  function onConnectionClosed(message) {
    if (readyState === EventSource$1.CLOSED) return;
    readyState = EventSource$1.CONNECTING;
    _emit('error', new Event('error', {
      message: message
    }));

    // The url may have been changed by a temporary redirect. If that's the case,
    // revert it now, and flag that we are no longer pointing to a new origin
    if (reconnectUrl) {
      url = reconnectUrl;
      reconnectUrl = null;
      hasNewOrigin = false;
    }
    setTimeout(function () {
      if (readyState !== EventSource$1.CONNECTING || self.connectionInProgress) {
        return;
      }
      self.connectionInProgress = true;
      connect();
    }, self.reconnectInterval);
  }
  var req;
  var lastEventId = '';
  if (headers && headers['Last-Event-ID']) {
    lastEventId = headers['Last-Event-ID'];
    delete headers['Last-Event-ID'];
  }
  var discardTrailingNewline = false;
  var data = '';
  var eventName = '';
  var reconnectUrl = null;
  function connect() {
    var options = parse(url);
    var isSecure = options.protocol === 'https:';
    options.headers = {
      'Cache-Control': 'no-cache',
      'Accept': 'text/event-stream'
    };
    if (lastEventId) options.headers['Last-Event-ID'] = lastEventId;
    if (headers) {
      var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;
      for (var i in reqHeaders) {
        var header = reqHeaders[i];
        if (header) {
          options.headers[i] = header;
        }
      }
    }

    // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,
    // but for now exists as a backwards-compatibility layer
    options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);
    if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {
      options.createConnection = eventSourceInitDict.createConnection;
    }

    // If specify http proxy, make the request to sent to the proxy server,
    // and include the original url in path and Host headers
    var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
    if (useProxy) {
      var proxy = parse(eventSourceInitDict.proxy);
      isSecure = proxy.protocol === 'https:';
      options.protocol = isSecure ? 'https:' : 'http:';
      options.path = url;
      options.headers.Host = options.host;
      options.hostname = proxy.hostname;
      options.host = proxy.host;
      options.port = proxy.port;
    }

    // If https options are specified, merge them into the request options
    if (eventSourceInitDict && eventSourceInitDict.https) {
      for (var optName in eventSourceInitDict.https) {
        if (httpsOptions.indexOf(optName) === -1) {
          continue;
        }
        var option = eventSourceInitDict.https[optName];
        if (option !== undefined) {
          options[optName] = option;
        }
      }
    }

    // Pass this on to the XHR
    if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {
      options.withCredentials = eventSourceInitDict.withCredentials;
    }
    req = (isSecure ? https : http).request(options, function (res) {
      self.connectionInProgress = false;
      // Handle HTTP errors
      if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
        _emit('error', new Event('error', {
          status: res.statusCode,
          message: res.statusMessage
        }));
        onConnectionClosed();
        return;
      }

      // Handle HTTP redirects
      if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
        var location = res.headers.location;
        if (!location) {
          // Server sent redirect response without Location header.
          _emit('error', new Event('error', {
            status: res.statusCode,
            message: res.statusMessage
          }));
          return;
        }
        var prevOrigin = new URL(url).origin;
        var nextOrigin = new URL(location).origin;
        hasNewOrigin = prevOrigin !== nextOrigin;
        if (res.statusCode === 307) reconnectUrl = url;
        url = location;
        process.nextTick(connect);
        return;
      }
      if (res.statusCode !== 200) {
        _emit('error', new Event('error', {
          status: res.statusCode,
          message: res.statusMessage
        }));
        return self.close();
      }
      readyState = EventSource$1.OPEN;
      res.on('close', function () {
        res.removeAllListeners('close');
        res.removeAllListeners('end');
        onConnectionClosed();
      });
      res.on('end', function () {
        res.removeAllListeners('close');
        res.removeAllListeners('end');
        onConnectionClosed();
      });
      _emit('open', new Event('open'));

      // text/event-stream parser adapted from webkit's
      // Source/WebCore/page/EventSource.cpp
      var buf;
      var newBuffer;
      var startingPos = 0;
      var startingFieldLength = -1;
      var newBufferSize = 0;
      var bytesUsed = 0;
      res.on('data', function (chunk) {
        if (!buf) {
          buf = chunk;
          if (hasBom(buf)) {
            buf = buf.slice(bom.length);
          }
          bytesUsed = buf.length;
        } else {
          if (chunk.length > buf.length - bytesUsed) {
            newBufferSize = buf.length * 2 + chunk.length;
            if (newBufferSize > maxBufferAheadAllocation) {
              newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;
            }
            newBuffer = Buffer.alloc(newBufferSize);
            buf.copy(newBuffer, 0, 0, bytesUsed);
            buf = newBuffer;
          }
          chunk.copy(buf, bytesUsed);
          bytesUsed += chunk.length;
        }
        var pos = 0;
        var length = bytesUsed;
        while (pos < length) {
          if (discardTrailingNewline) {
            if (buf[pos] === lineFeed) {
              ++pos;
            }
            discardTrailingNewline = false;
          }
          var lineLength = -1;
          var fieldLength = startingFieldLength;
          var c;
          for (var i = startingPos; lineLength < 0 && i < length; ++i) {
            c = buf[i];
            if (c === colon) {
              if (fieldLength < 0) {
                fieldLength = i - pos;
              }
            } else if (c === carriageReturn) {
              discardTrailingNewline = true;
              lineLength = i - pos;
            } else if (c === lineFeed) {
              lineLength = i - pos;
            }
          }
          if (lineLength < 0) {
            startingPos = length - pos;
            startingFieldLength = fieldLength;
            break;
          } else {
            startingPos = 0;
            startingFieldLength = -1;
          }
          parseEventStreamLine(buf, pos, fieldLength, lineLength);
          pos += lineLength + 1;
        }
        if (pos === length) {
          buf = void 0;
          bytesUsed = 0;
        } else if (pos > 0) {
          buf = buf.slice(pos, bytesUsed);
          bytesUsed = buf.length;
        }
      });
    });
    req.on('error', function (err) {
      self.connectionInProgress = false;
      onConnectionClosed(err.message);
    });
    if (req.setNoDelay) req.setNoDelay(true);
    req.end();
  }
  connect();
  function _emit() {
    if (self.listeners(arguments[0]).length > 0) {
      self.emit.apply(self, arguments);
    }
  }
  this._close = function () {
    if (readyState === EventSource$1.CLOSED) return;
    readyState = EventSource$1.CLOSED;
    if (req.abort) req.abort();
    if (req.xhr && req.xhr.abort) req.xhr.abort();
  };
  function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
    if (lineLength === 0) {
      if (data.length > 0) {
        var type = eventName || 'message';
        _emit(type, new MessageEvent(type, {
          data: data.slice(0, -1),
          // remove trailing newline
          lastEventId: lastEventId,
          origin: new URL(url).origin
        }));
        data = '';
      }
      eventName = void 0;
    } else if (fieldLength > 0) {
      var noValue = fieldLength < 0;
      var step = 0;
      var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
      if (noValue) {
        step = lineLength;
      } else if (buf[pos + fieldLength + 1] !== space) {
        step = fieldLength + 1;
      } else {
        step = fieldLength + 2;
      }
      pos += step;
      var valueLength = lineLength - step;
      var value = buf.slice(pos, pos + valueLength).toString();
      if (field === 'data') {
        data += value + '\n';
      } else if (field === 'event') {
        eventName = value;
      } else if (field === 'id') {
        lastEventId = value;
      } else if (field === 'retry') {
        var retry = parseInt(value, 10);
        if (!Number.isNaN(retry)) {
          self.reconnectInterval = retry;
        }
      }
    }
  }
}
var eventsource = EventSource$1;
util.inherits(EventSource$1, events.EventEmitter);
EventSource$1.prototype.constructor = EventSource$1; // make stacktraces readable

['open', 'error', 'message'].forEach(function (method) {
  Object.defineProperty(EventSource$1.prototype, 'on' + method, {
    /**
     * Returns the current listener
     *
     * @return {Mixed} the set function or undefined
     * @api private
     */
    get: function get() {
      var listener = this.listeners(method)[0];
      return listener ? listener._listener ? listener._listener : listener : undefined;
    },
    /**
     * Start listening for events
     *
     * @param {Function} listener the listener
     * @return {Mixed} the set function or undefined
     * @api private
     */
    set: function set(listener) {
      this.removeAllListeners(method);
      this.addEventListener(method, listener);
    }
  });
});

/**
 * Ready states
 */
Object.defineProperty(EventSource$1, 'CONNECTING', {
  enumerable: true,
  value: 0
});
Object.defineProperty(EventSource$1, 'OPEN', {
  enumerable: true,
  value: 1
});
Object.defineProperty(EventSource$1, 'CLOSED', {
  enumerable: true,
  value: 2
});
EventSource$1.prototype.CONNECTING = 0;
EventSource$1.prototype.OPEN = 1;
EventSource$1.prototype.CLOSED = 2;

/**
 * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close
 * @api public
 */
EventSource$1.prototype.close = function () {
  this._close();
};

/**
 * Emulates the W3C Browser based WebSocket interface using addEventListener.
 *
 * @param {String} type A string representing the event type to listen out for
 * @param {Function} listener callback
 * @see https://developer.mozilla.org/en/DOM/element.addEventListener
 * @see http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @api public
 */
EventSource$1.prototype.addEventListener = function addEventListener(type, listener) {
  if (typeof listener === 'function') {
    // store a reference so we can return the original function again
    listener._listener = listener;
    this.on(type, listener);
  }
};

/**
 * Emulates the W3C Browser based WebSocket interface using dispatchEvent.
 *
 * @param {Event} event An event to be dispatched
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
 * @api public
 */
EventSource$1.prototype.dispatchEvent = function dispatchEvent(event) {
  if (!event.type) {
    throw new Error('UNSPECIFIED_EVENT_TYPE_ERR');
  }
  // if event is instance of an CustomEvent (or has 'details' property),
  // send the detail object as the payload for the event
  this.emit(event.type, event.detail);
};

/**
 * Emulates the W3C Browser based WebSocket interface using removeEventListener.
 *
 * @param {String} type A string representing the event type to remove
 * @param {Function} listener callback
 * @see https://developer.mozilla.org/en/DOM/element.removeEventListener
 * @see http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @api public
 */
EventSource$1.prototype.removeEventListener = function removeEventListener(type, listener) {
  if (typeof listener === 'function') {
    listener._listener = undefined;
    this.removeListener(type, listener);
  }
};

/**
 * W3C Event
 *
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event
 * @api private
 */
function Event(type, optionalProperties) {
  Object.defineProperty(this, 'type', {
    writable: false,
    value: type,
    enumerable: true
  });
  if (optionalProperties) {
    for (var f in optionalProperties) {
      if (optionalProperties.hasOwnProperty(f)) {
        Object.defineProperty(this, f, {
          writable: false,
          value: optionalProperties[f],
          enumerable: true
        });
      }
    }
  }
}

/**
 * W3C MessageEvent
 *
 * @see http://www.w3.org/TR/webmessaging/#event-definitions
 * @api private
 */
function MessageEvent(type, eventInitDict) {
  Object.defineProperty(this, 'type', {
    writable: false,
    value: type,
    enumerable: true
  });
  for (var f in eventInitDict) {
    if (eventInitDict.hasOwnProperty(f)) {
      Object.defineProperty(this, f, {
        writable: false,
        value: eventInitDict[f],
        enumerable: true
      });
    }
  }
}

/**
 * Returns a new object of headers that does not include any authorization and cookie headers
 *
 * @param {Object} headers An object of headers ({[headerName]: headerValue})
 * @return {Object} a new object of headers
 * @api private
 */
function removeUnsafeHeaders(headers) {
  var safe = {};
  for (var key in headers) {
    if (reUnsafeHeader.test(key)) {
      continue;
    }
    safe[key] = headers[key];
  }
  return safe;
}
(function (module) {
  module.exports = eventsource;
})(node$1);
var pick$1 = function (obj, props) {
  return props.reduce(function (selection, prop) {
    if (typeof obj[prop] === 'undefined') {
      return selection;
    }
    selection[prop] = obj[prop];
    return selection;
  }, {});
};
var defaults$1 = function (obj, defaults) {
  return Object.keys(defaults).concat(Object.keys(obj)).reduce(function (target, prop) {
    target[prop] = typeof obj[prop] === 'undefined' ? defaults[prop] : obj[prop];
    return target;
  }, {});
};
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var assign$a = objectAssign;
var _require$4 = observable$1,
  Observable$2 = _require$4.Observable;
var polyfilledEventSource = node$1.exports;
var pick = pick$1;
var defaults = defaults$1;
var encodeQueryString$1 = encodeQueryString$2; // Limit is 16K for a _request_, eg including headers. Have to account for an
// unknown range of headers, but an average EventSource request from Chrome seems
// to have around 700 bytes of cruft, so let us account for 1.2K to be "safe"

var MAX_URL_LENGTH = 16000 - 1200;
var EventSource = polyfilledEventSource;
var possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat', 'tag'];
var defaultOptions = {
  includeResult: true
};
var listen$1 = function listen(query, params) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _this$clientConfig = this.clientConfig,
    url = _this$clientConfig.url,
    token = _this$clientConfig.token,
    withCredentials = _this$clientConfig.withCredentials,
    requestTagPrefix = _this$clientConfig.requestTagPrefix;
  var tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join('.') : opts.tag;
  var options = _objectSpread$1(_objectSpread$1({}, defaults(opts, defaultOptions)), {}, {
    tag: tag
  });
  var listenOpts = pick(options, possibleOptions);
  var qs = encodeQueryString$1({
    query: query,
    params: params,
    options: listenOpts,
    tag: tag
  });
  var uri = "".concat(url).concat(this.getDataUrl('listen', qs));
  if (uri.length > MAX_URL_LENGTH) {
    return new Observable$2(function (observer) {
      return observer.error(new Error('Query too large for listener'));
    });
  }
  var listenFor = options.events ? options.events : ['mutation'];
  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;
  var esOptions = {};
  if (token || withCredentials) {
    esOptions.withCredentials = true;
  }
  if (token) {
    esOptions.headers = {
      Authorization: "Bearer ".concat(token)
    };
  }
  return new Observable$2(function (observer) {
    var es = getEventSource();
    var reconnectTimer;
    var stopped = false;
    function onError() {
      if (stopped) {
        return;
      }
      emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt

      if (stopped) {
        return;
      } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),
      // we should never be in a disconnected state. By default, EventSource will reconnect
      // automatically, in which case it sets readyState to `CONNECTING`, but in some cases
      // (like when a laptop lid is closed), it closes the connection. In these cases we need
      // to explicitly reconnect.

      if (es.readyState === EventSource.CLOSED) {
        unsubscribe();
        clearTimeout(reconnectTimer);
        reconnectTimer = setTimeout(open, 100);
      }
    }
    function onChannelError(err) {
      observer.error(cooerceError(err));
    }
    function onMessage(evt) {
      var event = parseEvent(evt);
      return event instanceof Error ? observer.error(event) : observer.next(event);
    }
    function onDisconnect(evt) {
      stopped = true;
      unsubscribe();
      observer.complete();
    }
    function unsubscribe() {
      es.removeEventListener('error', onError, false);
      es.removeEventListener('channelError', onChannelError, false);
      es.removeEventListener('disconnect', onDisconnect, false);
      listenFor.forEach(function (type) {
        return es.removeEventListener(type, onMessage, false);
      });
      es.close();
    }
    function emitReconnect() {
      if (shouldEmitReconnect) {
        observer.next({
          type: 'reconnect'
        });
      }
    }
    function getEventSource() {
      var evs = new EventSource(uri, esOptions);
      evs.addEventListener('error', onError, false);
      evs.addEventListener('channelError', onChannelError, false);
      evs.addEventListener('disconnect', onDisconnect, false);
      listenFor.forEach(function (type) {
        return evs.addEventListener(type, onMessage, false);
      });
      return evs;
    }
    function open() {
      es = getEventSource();
    }
    function stop() {
      stopped = true;
      unsubscribe();
    }
    return stop;
  });
};
function parseEvent(event) {
  try {
    var data = event.data && JSON.parse(event.data) || {};
    return assign$a({
      type: event.type
    }, data);
  } catch (err) {
    return err;
  }
}
function cooerceError(err) {
  if (err instanceof Error) {
    return err;
  }
  var evt = parseEvent(err);
  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));
}
function extractErrorMessage(err) {
  if (!err.error) {
    return err.message || 'Unknown listener error';
  }
  if (err.error.description) {
    return err.error.description;
  }
  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var assign$9 = objectAssign;
var _require$3 = observable$1,
  map$2 = _require$3.map,
  filter$2 = _require$3.filter;
var validators$1 = validators$3;
var getSelection = getSelection$2;
var encodeQueryString = encodeQueryString$2;
var Transaction$1 = transaction;
var Patch$1 = patch;
var listen = listen$1;
var excludeFalsey = function excludeFalsey(param, defValue) {
  var value = typeof param === 'undefined' ? defValue : param;
  return param === false ? undefined : value;
};
var getMutationQuery = function getMutationQuery() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    dryRun: options.dryRun,
    returnIds: true,
    returnDocuments: excludeFalsey(options.returnDocuments, true),
    visibility: options.visibility || 'sync',
    autoGenerateArrayKeys: options.autoGenerateArrayKeys,
    skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation
  };
};
var isResponse = function isResponse(event) {
  return event.type === 'response';
};
var getBody = function getBody(event) {
  return event.body;
};
var indexBy = function indexBy(docs, attr) {
  return docs.reduce(function (indexed, doc) {
    indexed[attr(doc)] = doc;
    return indexed;
  }, Object.create(null));
};
var toPromise$1 = function toPromise(observable) {
  return observable.toPromise();
};
var getQuerySizeLimit = 11264;
var dataMethods$1 = {
  listen: listen,
  getDataUrl: function getDataUrl(operation, path) {
    var config = this.clientConfig;
    var catalog = validators$1.hasDataset(config);
    var baseUri = "/".concat(operation, "/").concat(catalog);
    var uri = path ? "".concat(baseUri, "/").concat(path) : baseUri;
    return "/data".concat(uri).replace(/\/($|\?)/, '$1');
  },
  fetch: function fetch(query, params) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var mapResponse = options.filterResponse === false ? function (res) {
      return res;
    } : function (res) {
      return res.result;
    };
    var observable = this._dataRequest('query', {
      query: query,
      params: params
    }, options).pipe(map$2(mapResponse));
    return this.isPromiseAPI() ? toPromise$1(observable) : observable;
  },
  getDocument: function getDocument(id) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = {
      uri: this.getDataUrl('doc', id),
      json: true,
      tag: opts.tag
    };
    var observable = this._requestObservable(options).pipe(filter$2(isResponse), map$2(function (event) {
      return event.body.documents && event.body.documents[0];
    }));
    return this.isPromiseAPI() ? toPromise$1(observable) : observable;
  },
  getDocuments: function getDocuments(ids) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = {
      uri: this.getDataUrl('doc', ids.join(',')),
      json: true,
      tag: opts.tag
    };
    var observable = this._requestObservable(options).pipe(filter$2(isResponse), map$2(function (event) {
      var indexed = indexBy(event.body.documents || [], function (doc) {
        return doc._id;
      });
      return ids.map(function (id) {
        return indexed[id] || null;
      });
    }));
    return this.isPromiseAPI() ? toPromise$1(observable) : observable;
  },
  create: function create(doc, options) {
    return this._create(doc, 'create', options);
  },
  createIfNotExists: function createIfNotExists(doc, options) {
    validators$1.requireDocumentId('createIfNotExists', doc);
    return this._create(doc, 'createIfNotExists', options);
  },
  createOrReplace: function createOrReplace(doc, options) {
    validators$1.requireDocumentId('createOrReplace', doc);
    return this._create(doc, 'createOrReplace', options);
  },
  patch: function patch(selector, operations) {
    return new Patch$1(selector, operations, this);
  },
  delete: function _delete(selection, options) {
    return this.dataRequest('mutate', {
      mutations: [{
        delete: getSelection(selection)
      }]
    }, options);
  },
  mutate: function mutate(mutations, options) {
    var mut = mutations instanceof Patch$1 || mutations instanceof Transaction$1 ? mutations.serialize() : mutations;
    var muts = Array.isArray(mut) ? mut : [mut];
    var transactionId = options && options.transactionId;
    return this.dataRequest('mutate', {
      mutations: muts,
      transactionId: transactionId
    }, options);
  },
  transaction: function transaction(operations) {
    return new Transaction$1(operations, this);
  },
  dataRequest: function dataRequest(endpoint, body) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var request = this._dataRequest(endpoint, body, options);
    return this.isPromiseAPI() ? toPromise$1(request) : request;
  },
  _dataRequest: function _dataRequest(endpoint, body) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var isMutation = endpoint === 'mutate';
    var isQuery = endpoint === 'query'; // Check if the query string is within a configured threshold,
    // in which case we can use GET. Otherwise, use POST.

    var strQuery = !isMutation && encodeQueryString(body);
    var useGet = !isMutation && strQuery.length < getQuerySizeLimit;
    var stringQuery = useGet ? strQuery : '';
    var returnFirst = options.returnFirst;
    var timeout = options.timeout,
      token = options.token,
      tag = options.tag,
      headers = options.headers;
    var uri = this.getDataUrl(endpoint, stringQuery);
    var reqOptions = {
      method: useGet ? 'GET' : 'POST',
      uri: uri,
      json: true,
      body: useGet ? undefined : body,
      query: isMutation && getMutationQuery(options),
      timeout: timeout,
      headers: headers,
      token: token,
      tag: tag,
      canUseCdn: isQuery
    };
    return this._requestObservable(reqOptions).pipe(filter$2(isResponse), map$2(getBody), map$2(function (res) {
      if (!isMutation) {
        return res;
      } // Should we return documents?

      var results = res.results || [];
      if (options.returnDocuments) {
        return returnFirst ? results[0] && results[0].document : results.map(function (mut) {
          return mut.document;
        });
      } // Return a reduced subset

      var key = returnFirst ? 'documentId' : 'documentIds';
      var ids = returnFirst ? results[0] && results[0].id : results.map(function (mut) {
        return mut.id;
      });
      return _defineProperty$1({
        transactionId: res.transactionId,
        results: results
      }, key, ids);
    }));
  },
  _create: function _create(doc, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var mutation = _defineProperty$1({}, op, doc);
    var opts = assign$9({
      returnFirst: true,
      returnDocuments: true
    }, options);
    return this.dataRequest('mutate', {
      mutations: [mutation]
    }, opts);
  }
};
var assign$8 = objectAssign;
var validate$1 = validators$3;
function DatasetsClient$1(client) {
  this.request = client.request.bind(client);
}
assign$8(DatasetsClient$1.prototype, {
  create: function create(name, options) {
    return this._modify('PUT', name, options);
  },
  edit: function edit(name, options) {
    return this._modify('PATCH', name, options);
  },
  delete: function _delete(name) {
    return this._modify('DELETE', name);
  },
  list: function list() {
    return this.request({
      uri: '/datasets'
    });
  },
  _modify: function _modify(method, name, body) {
    validate$1.dataset(name);
    return this.request({
      method: method,
      uri: "/datasets/".concat(name),
      body: body
    });
  }
});
var datasetsClient = DatasetsClient$1;
var assign$7 = objectAssign;
function ProjectsClient$1(client) {
  this.client = client;
}
assign$7(ProjectsClient$1.prototype, {
  list: function list() {
    return this.client.request({
      uri: '/projects'
    });
  },
  getById: function getById(id) {
    return this.client.request({
      uri: "/projects/".concat(id)
    });
  }
});
var projectsClient = ProjectsClient$1;
var queryString$1 = function (params) {
  var qs = [];
  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(params[key])));
    }
  }
  return qs.length > 0 ? "?".concat(qs.join('&')) : '';
};
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
var assign$6 = objectAssign;
var _require$2 = observable$1,
  map$1 = _require$2.map,
  filter$1 = _require$2.filter;
var queryString = queryString$1;
var validators = validators$3;
function AssetsClient$1(client) {
  this.client = client;
}
function optionsFromFile(opts, file) {
  if (typeof window === 'undefined' || !(file instanceof window.File)) {
    return opts;
  }
  return assign$6({
    filename: opts.preserveFilename === false ? undefined : file.name,
    contentType: file.type
  }, opts);
}
assign$6(AssetsClient$1.prototype, {
  /**
   * Upload an asset
   *
   * @param  {String} assetType `image` or `file`
   * @param  {File|Blob|Buffer|ReadableStream} body File to upload
   * @param  {Object}  opts Options for the upload
   * @param  {Boolean} opts.preserveFilename Whether or not to preserve the original filename (default: true)
   * @param  {String}  opts.filename Filename for this file (optional)
   * @param  {Number}  opts.timeout  Milliseconds to wait before timing the request out (default: 0)
   * @param  {String}  opts.contentType Mime type of the file
   * @param  {Array}   opts.extract Array of metadata parts to extract from image.
   *                                 Possible values: `location`, `exif`, `image`, `palette`
   * @param  {String}  opts.label Label
   * @param  {String}  opts.title Title
   * @param  {String}  opts.description Description
   * @param  {String}  opts.creditLine The credit to person(s) and/or organization(s) required by the supplier of the image to be used when published
   * @param  {Object}  opts.source Source data (when the asset is from an external service)
   * @param  {String}  opts.source.id The (u)id of the asset within the source, i.e. 'i-f323r1E'
   *                                  Required if source is defined
   * @param  {String}  opts.source.name The name of the source, i.e. 'unsplash'
   *                                  Required if source is defined
   * @param  {String}  opts.source.url A url to where to find the asset, or get more info about it in the source
   *                                  Optional
   * @return {Promise} Resolves with the created asset document
   */
  upload: function upload(assetType, body) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    validators.validateAssetType(assetType); // If an empty array is given, explicitly set `none` to override API defaults

    var meta = opts.extract || undefined;
    if (meta && !meta.length) {
      meta = ['none'];
    }
    var dataset = validators.hasDataset(this.client.clientConfig);
    var assetEndpoint = assetType === 'image' ? 'images' : 'files';
    var options = optionsFromFile(opts, body);
    var tag = options.tag,
      label = options.label,
      title = options.title,
      description = options.description,
      creditLine = options.creditLine,
      filename = options.filename,
      source = options.source;
    var query = {
      label: label,
      title: title,
      description: description,
      filename: filename,
      meta: meta,
      creditLine: creditLine
    };
    if (source) {
      query.sourceId = source.id;
      query.sourceName = source.name;
      query.sourceUrl = source.url;
    }
    var observable = this.client._requestObservable({
      tag: tag,
      method: 'POST',
      timeout: options.timeout || 0,
      uri: "/assets/".concat(assetEndpoint, "/").concat(dataset),
      headers: options.contentType ? {
        'Content-Type': options.contentType
      } : {},
      query: query,
      body: body
    });
    return this.client.isPromiseAPI() ? observable.pipe(filter$1(function (event) {
      return event.type === 'response';
    }), map$1(function (event) {
      return event.body.document;
    })).toPromise() : observable;
  },
  delete: function _delete(type, id) {
    // eslint-disable-next-line no-console
    console.warn('client.assets.delete() is deprecated, please use client.delete(<document-id>)');
    var docId = id || '';
    if (!/^(image|file)-/.test(docId)) {
      docId = "".concat(type, "-").concat(docId);
    } else if (type._id) {
      // We could be passing an entire asset document instead of an ID
      docId = type._id;
    }
    validators.hasDataset(this.client.clientConfig);
    return this.client.delete(docId);
  },
  getImageUrl: function getImageUrl(ref, query) {
    var id = ref._ref || ref;
    if (typeof id !== 'string') {
      throw new Error('getImageUrl() needs either an object with a _ref, or a string with an asset document ID');
    }
    if (!/^image-[A-Za-z0-9_]+-\d+x\d+-[a-z]{1,5}$/.test(id)) {
      throw new Error("Unsupported asset ID \"".concat(id, "\". URL generation only works for auto-generated IDs."));
    }
    var _id$split = id.split('-'),
      _id$split2 = _slicedToArray(_id$split, 4),
      assetId = _id$split2[1],
      size = _id$split2[2],
      format = _id$split2[3];
    validators.hasDataset(this.client.clientConfig);
    var _this$client$clientCo = this.client.clientConfig,
      projectId = _this$client$clientCo.projectId,
      dataset = _this$client$clientCo.dataset;
    var qs = query ? queryString(query) : '';
    return "https://cdn.sanity.io/images/".concat(projectId, "/").concat(dataset, "/").concat(assetId, "-").concat(size, ".").concat(format).concat(qs);
  }
});
var assetsClient = AssetsClient$1;
var assign$5 = objectAssign;
function UsersClient$1(client) {
  this.client = client;
}
assign$5(UsersClient$1.prototype, {
  getById: function getById(id) {
    return this.client.request({
      uri: "/users/".concat(id)
    });
  }
});
var usersClient = UsersClient$1;
var assign$4 = objectAssign;
function AuthClient$1(client) {
  this.client = client;
}
assign$4(AuthClient$1.prototype, {
  getLoginProviders: function getLoginProviders() {
    return this.client.request({
      uri: '/auth/providers'
    });
  },
  logout: function logout() {
    return this.client.request({
      uri: '/auth/logout',
      method: 'POST'
    });
  }
});
var authClient = AuthClient$1;
var errors = {};
var makeError$1 = {
  exports: {}
};
(function (module, exports) {
  // ===================================================================

  var construct = typeof Reflect !== "undefined" ? Reflect.construct : undefined;
  var defineProperty = Object.defineProperty;

  // -------------------------------------------------------------------

  var captureStackTrace = Error.captureStackTrace;
  if (captureStackTrace === undefined) {
    captureStackTrace = function captureStackTrace(error) {
      var container = new Error();
      defineProperty(error, "stack", {
        configurable: true,
        get: function getStack() {
          var stack = container.stack;

          // Replace property with value for faster future accesses.
          defineProperty(this, "stack", {
            configurable: true,
            value: stack,
            writable: true
          });
          return stack;
        },
        set: function setStack(stack) {
          defineProperty(error, "stack", {
            configurable: true,
            value: stack,
            writable: true
          });
        }
      });
    };
  }

  // -------------------------------------------------------------------

  function BaseError(message) {
    if (message !== undefined) {
      defineProperty(this, "message", {
        configurable: true,
        value: message,
        writable: true
      });
    }
    var cname = this.constructor.name;
    if (cname !== undefined && cname !== this.name) {
      defineProperty(this, "name", {
        configurable: true,
        value: cname,
        writable: true
      });
    }
    captureStackTrace(this, this.constructor);
  }
  BaseError.prototype = Object.create(Error.prototype, {
    // See: https://github.com/JsCommunity/make-error/issues/4
    constructor: {
      configurable: true,
      value: BaseError,
      writable: true
    }
  });

  // -------------------------------------------------------------------

  // Sets the name of a function if possible (depends of the JS engine).
  var setFunctionName = function () {
    function setFunctionName(fn, name) {
      return defineProperty(fn, "name", {
        configurable: true,
        value: name
      });
    }
    try {
      var f = function () {};
      setFunctionName(f, "foo");
      if (f.name === "foo") {
        return setFunctionName;
      }
    } catch (_) {}
  }();

  // -------------------------------------------------------------------

  function makeError(constructor, super_) {
    if (super_ == null || super_ === Error) {
      super_ = BaseError;
    } else if (typeof super_ !== "function") {
      throw new TypeError("super_ should be a function");
    }
    var name;
    if (typeof constructor === "string") {
      name = constructor;
      constructor = construct !== undefined ? function () {
        return construct(super_, arguments, this.constructor);
      } : function () {
        super_.apply(this, arguments);
      };

      // If the name can be set, do it once and for all.
      if (setFunctionName !== undefined) {
        setFunctionName(constructor, name);
        name = undefined;
      }
    } else if (typeof constructor !== "function") {
      throw new TypeError("constructor should be either a string or a function");
    }

    // Also register the super constructor also as `constructor.super_` just
    // like Node's `util.inherits()`.
    //
    // eslint-disable-next-line dot-notation
    constructor.super_ = constructor["super"] = super_;
    var properties = {
      constructor: {
        configurable: true,
        value: constructor,
        writable: true
      }
    };

    // If the name could not be set on the constructor, set it on the
    // prototype.
    if (name !== undefined) {
      properties.name = {
        configurable: true,
        value: name,
        writable: true
      };
    }
    constructor.prototype = Object.create(super_.prototype, properties);
    return constructor;
  }
  exports = module.exports = makeError;
  exports.BaseError = BaseError;
})(makeError$1, makeError$1.exports);
var makeError = makeError$1.exports;
var assign$3 = objectAssign;
function ClientError$1(res) {
  var props = extractErrorProps(res);
  ClientError$1.super.call(this, props.message);
  assign$3(this, props);
}
function ServerError$1(res) {
  var props = extractErrorProps(res);
  ServerError$1.super.call(this, props.message);
  assign$3(this, props);
}
function extractErrorProps(res) {
  var body = res.body;
  var props = {
    response: res,
    statusCode: res.statusCode,
    responseBody: stringifyBody(body, res)
  }; // API/Boom style errors ({statusCode, error, message})

  if (body.error && body.message) {
    props.message = "".concat(body.error, " - ").concat(body.message);
    return props;
  } // Query/database errors ({error: {description, other, arb, props}})

  if (body.error && body.error.description) {
    props.message = body.error.description;
    props.details = body.error;
    return props;
  } // Other, more arbitrary errors

  props.message = body.error || body.message || httpErrorMessage(res);
  return props;
}
function httpErrorMessage(res) {
  var statusMessage = res.statusMessage ? " ".concat(res.statusMessage) : '';
  return "".concat(res.method, "-request to ").concat(res.url, " resulted in HTTP ").concat(res.statusCode).concat(statusMessage);
}
function stringifyBody(body, res) {
  var contentType = (res.headers['content-type'] || '').toLowerCase();
  var isJson = contentType.indexOf('application/json') !== -1;
  return isJson ? JSON.stringify(body, null, 2) : body;
}
makeError(ClientError$1);
makeError(ServerError$1);
errors.ClientError = ClientError$1;
errors.ServerError = ServerError$1;
var name = "@sanity/client";
var version = "3.4.1";
var description = "Client for retrieving, creating and patching data from Sanity.io";
var main = "lib/sanityClient.js";
var umd = "umd/sanityClient.min.js";
var unpkg = "umd/sanityClient.min.js";
var types = "./sanityClient.d.ts";
var files = ["dist", "lib", "umd", "sanityClient.d.ts"];
var scripts = {
  browserify: "NODE_ENV=production BROWSERIFY_ENV=build DEBUG='' browserify -t envify -g uglifyify lib/sanityClient.js -o umd/sanityClient.js --standalone=SanityClient",
  compile: "babel -d lib src",
  build: "npm run compile && npm run browserify && npm run minify && npm run esbuild:browser",
  esbuild: "esbuild src/sanityClient.js --bundle --sourcemap --external:object-assign --external:rxjs --external:@sanity/eventsource --external:get-it --external:make-error",
  "esbuild:browser": "npm run esbuild -- --format=esm --outfile=dist/sanityClient.browser.mjs --platform=browser",
  lint: "eslint .",
  clean: "rimraf dist lib coverage .nyc_output umd/*.js",
  typecheck: "tsc --lib es2015 --lib dom,es2015  --noEmit sanityClient.d.ts",
  coverage: "DEBUG=sanity NODE_ENV=test nyc --reporter=html --reporter=lcov --reporter=text npm test",
  minify: "terser -c -m -- umd/sanityClient.js > umd/sanityClient.min.js",
  prepublishOnly: "npm run clean && npm run build",
  test: "NODE_ENV=test tape test/*.test.js",
  posttest: "npm run lint && npm run typecheck --strict"
};
var browser$1 = {
  "./src/http/nodeMiddleware.js": "./src/http/browserMiddleware.js",
  "./lib/http/nodeMiddleware.js": "./lib/http/browserMiddleware.js"
};
var engines = {
  node: ">=12"
};
var dependencies = {
  "@sanity/eventsource": "^4.0.0",
  "get-it": "^6.1.1",
  "make-error": "^1.3.0",
  "object-assign": "^4.1.1",
  rxjs: "^6.0.0"
};
var devDependencies = {
  "@babel/cli": "^7.18.10",
  "@babel/core": "^7.18.10",
  "@babel/preset-env": "^7.18.10",
  "@types/node": "^16.11.49",
  browserify: "^17.0.0",
  envify: "^4.0.0",
  esbuild: "^0.15.5",
  eslint: "^8.21.0",
  "eslint-config-prettier": "^8.5.0",
  "eslint-config-sanity": "^6.0.0",
  nock: "^13.2.9",
  nyc: "^15.1.0",
  prettier: "^2.7.1",
  rimraf: "^3.0.2",
  "sse-channel": "^4.0.0",
  tape: "^5.5.3",
  terser: "^5.12.1",
  typescript: "^4.7.4",
  uglifyify: "^5.0.0",
  xtend: "4.0.2"
};
var repository = {
  type: "git",
  url: "git+https://github.com/sanity-io/client.git"
};
var keywords = ["sanity", "cms", "headless", "realtime", "content", "client", "fetch", "api"];
var author = "Sanity.io <hello@sanity.io>";
var license = "MIT";
var bugs = {
  url: "https://github.com/sanity-io/client/issues"
};
var homepage = "https://www.sanity.io/";
var nyc = {
  include: ["src/**/*.js"],
  sourceMap: false
};
var prettier = {
  semi: false,
  printWidth: 100,
  bracketSpacing: false,
  singleQuote: true
};
var require$$3 = {
  name: name,
  version: version,
  description: description,
  main: main,
  umd: umd,
  unpkg: unpkg,
  types: types,
  files: files,
  scripts: scripts,
  browser: browser$1,
  engines: engines,
  dependencies: dependencies,
  devDependencies: devDependencies,
  repository: repository,
  keywords: keywords,
  author: author,
  license: license,
  bugs: bugs,
  homepage: homepage,
  nyc: nyc,
  prettier: prettier
};
var retry = require$$0__default$2["default"];
var debug$1 = require$$1__default["default"];
var headers = require$$2__default$2["default"];
var pkg = require$$3;
var middleware$1 = [debug$1({
  verbose: true,
  namespace: 'sanity:client'
}), headers({
  'User-Agent': "".concat(pkg.name, " ").concat(pkg.version)
}), retry({
  maxRetries: 3
})];
var nodeMiddleware = middleware$1;

/* eslint-disable no-empty-function, no-process-env */
var getIt = require$$0__default$3["default"];
var assign$2 = objectAssign;
var observable = require$$2__default$3["default"];
var jsonRequest = require$$3__default$1["default"];
var jsonResponse = require$$4__default["default"];
var progress = require$$5__default["default"];
var _require$1 = observable$1,
  Observable$1 = _require$1.Observable;
var _require2$1 = errors,
  ClientError = _require2$1.ClientError,
  ServerError = _require2$1.ServerError;
var httpError = {
  onResponse: function onResponse(res) {
    if (res.statusCode >= 500) {
      throw new ServerError(res);
    } else if (res.statusCode >= 400) {
      throw new ClientError(res);
    }
    return res;
  }
};
var printWarnings = {
  onResponse: function onResponse(res) {
    var warn = res.headers['x-sanity-warning'];
    var warnings = Array.isArray(warn) ? warn : [warn];
    warnings.filter(Boolean).forEach(function (msg) {
      return console.warn(msg);
    }); // eslint-disable-line no-console

    return res;
  }
}; // Environment-specific middleware.

var envSpecific = nodeMiddleware;
var middleware = envSpecific.concat([printWarnings, jsonRequest(), jsonResponse(), progress(), httpError, observable({
  implementation: Observable$1
})]);
var request = getIt(middleware);
function httpRequest$1(options) {
  var requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : request;
  return requester(assign$2({
    maxRedirects: 0
  }, options));
}
httpRequest$1.defaultRequester = request;
httpRequest$1.ClientError = ClientError;
httpRequest$1.ServerError = ServerError;
var request_1 = httpRequest$1;
var assign$1 = objectAssign;
var projectHeader = 'X-Sanity-Project-ID';
var requestOptions = function (config) {
  var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var headers = {};
  var token = overrides.token || config.token;
  if (token) {
    headers.Authorization = "Bearer ".concat(token);
  }
  if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {
    headers[projectHeader] = config.projectId;
  }
  var withCredentials = Boolean(typeof overrides.withCredentials === 'undefined' ? config.token || config.withCredentials : overrides.withCredentials);
  var timeout = typeof overrides.timeout === 'undefined' ? config.timeout : overrides.timeout;
  return assign$1({}, overrides, {
    headers: assign$1({}, headers, overrides.headers || {}),
    timeout: typeof timeout === 'undefined' ? 5 * 60 * 1000 : timeout,
    proxy: overrides.proxy || config.proxy,
    json: true,
    withCredentials: withCredentials
  });
};
var config = {};
var BASE_URL = 'https://docs.sanity.io/help/';
var generateHelpUrl$1 = function generateHelpUrl(slug) {
  return BASE_URL + slug;
};
var warnings = {};
var once$1 = function (fn) {
  var didCall = false;
  var returnValue;
  return function () {
    if (didCall) {
      return returnValue;
    }
    returnValue = fn.apply(void 0, arguments);
    didCall = true;
    return returnValue;
  };
};
var generateHelpUrl = generateHelpUrl$1;
var once = once$1;
var createWarningPrinter = function createWarningPrinter(message) {
  return (
    // eslint-disable-next-line no-console
    once(function () {
      var _console;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_console = console).warn.apply(_console, [message.join(' ')].concat(args));
    })
  );
};
warnings.printCdnWarning = createWarningPrinter(['You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and', "cheaper. Think about it! For more info, see ".concat(generateHelpUrl('js-client-cdn-configuration'), "."), 'To hide this warning, please set the `useCdn` option to either `true` or `false` when creating', 'the client.']);
warnings.printBrowserTokenWarning = createWarningPrinter(['You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.', "See ".concat(generateHelpUrl('js-client-browser-token'), " for more information and how to hide this warning.")]);
warnings.printNoApiVersionSpecifiedWarning = createWarningPrinter(['Using the Sanity client without specifying an API version is deprecated.', "See ".concat(generateHelpUrl('js-client-api-version'))]);
(function (exports) {
  var assign = objectAssign;
  var generateHelpUrl = generateHelpUrl$1;
  var validate = validators$3;
  var warnings$1 = warnings;
  var defaultCdnHost = 'apicdn.sanity.io';
  var defaultConfig = {
    apiHost: 'https://api.sanity.io',
    apiVersion: '1',
    useProjectHostname: true,
    isPromiseAPI: true
  };
  var LOCALHOSTS = ['localhost', '127.0.0.1', '0.0.0.0'];
  var isLocal = function isLocal(host) {
    return LOCALHOSTS.indexOf(host) !== -1;
  };
  exports.defaultConfig = defaultConfig; // eslint-disable-next-line complexity

  exports.initConfig = function (config, prevConfig) {
    var specifiedConfig = assign({}, prevConfig, config);
    if (!specifiedConfig.apiVersion) {
      warnings$1.printNoApiVersionSpecifiedWarning();
    }
    var newConfig = assign({}, defaultConfig, specifiedConfig);
    var projectBased = newConfig.useProjectHostname;
    if (typeof Promise === 'undefined') {
      var helpUrl = generateHelpUrl('js-client-promise-polyfill');
      throw new Error("No native Promise-implementation found, polyfill needed - see ".concat(helpUrl));
    }
    if (projectBased && !newConfig.projectId) {
      throw new Error('Configuration must contain `projectId`');
    }
    var isBrowser = typeof window !== 'undefined' && window.location && window.location.hostname;
    var isLocalhost = isBrowser && isLocal(window.location.hostname);
    if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {
      warnings$1.printBrowserTokenWarning();
    } else if (typeof newConfig.useCdn === 'undefined') {
      warnings$1.printCdnWarning();
    }
    if (projectBased) {
      validate.projectId(newConfig.projectId);
    }
    if (newConfig.dataset) {
      validate.dataset(newConfig.dataset);
    }
    if ('requestTagPrefix' in newConfig) {
      // Allow setting and unsetting request tag prefix
      newConfig.requestTagPrefix = newConfig.requestTagPrefix ? validate.requestTag(newConfig.requestTagPrefix).replace(/\.+$/, '') : undefined;
    }
    newConfig.apiVersion = "".concat(newConfig.apiVersion).replace(/^v/, '');
    newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;
    newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.withCredentials;
    exports.validateApiVersion(newConfig.apiVersion);
    var hostParts = newConfig.apiHost.split('://', 2);
    var protocol = hostParts[0];
    var host = hostParts[1];
    var cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;
    if (newConfig.useProjectHostname) {
      newConfig.url = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(host, "/v").concat(newConfig.apiVersion);
      newConfig.cdnUrl = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(cdnHost, "/v").concat(newConfig.apiVersion);
    } else {
      newConfig.url = "".concat(newConfig.apiHost, "/v").concat(newConfig.apiVersion);
      newConfig.cdnUrl = newConfig.url;
    }
    return newConfig;
  };
  exports.validateApiVersion = function validateApiVersion(apiVersion) {
    if (apiVersion === '1' || apiVersion === 'X') {
      return;
    }
    var apiDate = new Date(apiVersion);
    var apiVersionValid = /^\d{4}-\d{2}-\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0;
    if (!apiVersionValid) {
      throw new Error('Invalid API version string, expected `1` or date in format `YYYY-MM-DD`');
    }
  };
})(config);
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var assign = objectAssign;
var _require = observable$1,
  Observable = _require.Observable,
  map = _require.map,
  filter = _require.filter;
var Patch = patch;
var Transaction = transaction;
var dataMethods = dataMethods$1;
var DatasetsClient = datasetsClient;
var ProjectsClient = projectsClient;
var AssetsClient = assetsClient;
var UsersClient = usersClient;
var AuthClient = authClient;
var httpRequest = request_1;
var getRequestOptions = requestOptions;
var _require2 = config,
  defaultConfig = _require2.defaultConfig,
  initConfig = _require2.initConfig;
var validate = validators$3;
var toPromise = function toPromise(observable) {
  return observable.toPromise();
};
function SanityClient() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;
  if (!(this instanceof SanityClient)) {
    return new SanityClient(config);
  }
  this.config(config);
  this.assets = new AssetsClient(this);
  this.datasets = new DatasetsClient(this);
  this.projects = new ProjectsClient(this);
  this.users = new UsersClient(this);
  this.auth = new AuthClient(this);
  if (this.clientConfig.isPromiseAPI) {
    var observableConfig = assign({}, this.clientConfig, {
      isPromiseAPI: false
    });
    this.observable = new SanityClient(observableConfig);
  }
}
assign(SanityClient.prototype, dataMethods);
assign(SanityClient.prototype, {
  clone: function clone() {
    return new SanityClient(this.config());
  },
  config: function config(newConfig) {
    if (typeof newConfig === 'undefined') {
      return assign({}, this.clientConfig);
    }
    if (this.clientConfig && this.clientConfig.allowReconfigure === false) {
      throw new Error('Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client');
    }
    if (this.observable) {
      var observableConfig = assign({}, newConfig, {
        isPromiseAPI: false
      });
      this.observable.config(observableConfig);
    }
    this.clientConfig = initConfig(newConfig, this.clientConfig || {});
    return this;
  },
  withConfig: function withConfig(newConfig) {
    return new SanityClient(_objectSpread(_objectSpread({}, this.config()), newConfig));
  },
  getUrl: function getUrl(uri) {
    var useCdn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var base = useCdn ? this.clientConfig.cdnUrl : this.clientConfig.url;
    return "".concat(base, "/").concat(uri.replace(/^\//, ''));
  },
  isPromiseAPI: function isPromiseAPI() {
    return this.clientConfig.isPromiseAPI;
  },
  _requestObservable: function _requestObservable(options) {
    var _this = this;
    var uri = options.url || options.uri; // If the `canUseCdn`-option is not set we detect it automatically based on the method + URL.
    // Only the /data endpoint is currently available through API-CDN.

    var canUseCdn = typeof options.canUseCdn === 'undefined' ? ['GET', 'HEAD'].indexOf(options.method || 'GET') >= 0 && uri.indexOf('/data/') === 0 : options.canUseCdn;
    var useCdn = this.clientConfig.useCdn && canUseCdn;
    var tag = options.tag && this.clientConfig.requestTagPrefix ? [this.clientConfig.requestTagPrefix, options.tag].join('.') : options.tag || this.clientConfig.requestTagPrefix;
    if (tag) {
      options.query = _objectSpread({
        tag: validate.requestTag(tag)
      }, options.query);
    }
    var reqOptions = getRequestOptions(this.clientConfig, assign({}, options, {
      url: this.getUrl(uri, useCdn)
    }));
    return new Observable(function (subscriber) {
      return httpRequest(reqOptions, _this.clientConfig.requester).subscribe(subscriber);
    });
  },
  request: function request(options) {
    var observable = this._requestObservable(options).pipe(filter(function (event) {
      return event.type === 'response';
    }), map(function (event) {
      return event.body;
    }));
    return this.isPromiseAPI() ? toPromise(observable) : observable;
  }
});
SanityClient.Patch = Patch;
SanityClient.Transaction = Transaction;
SanityClient.ClientError = httpRequest.ClientError;
SanityClient.ServerError = httpRequest.ServerError;
SanityClient.requester = httpRequest.defaultRequester;
var sanityClient = SanityClient;
var src = {
  exports: {}
};
var browser = {
  exports: {}
};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  ms = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    /**
    * Active `debug` instances.
    */

    createDebug.instances = [];
    /**
    * The currently active debug mode names, and names to skip.
    */

    createDebug.names = [];
    createDebug.skips = [];
    /**
    * Map of special "%n" handling functions, for the debug "format" argument.
    *
    * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    */

    createDebug.formatters = {};
    /**
    * Selects a color for a debug namespace
    * @param {String} namespace The namespace string for the for the debug instance to be colored
    * @return {Number|String} An ANSI color code for the given namespace
    * @api private
    */

    function selectColor(namespace) {
      var hash = 0;
      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
    * Create a debugger with the given `namespace`.
    *
    * @param {String} namespace
    * @return {Function}
    * @api public
    */

    function createDebug(namespace) {
      var prevTime;
      function debug() {
        // Disabled?
        if (!debug.enabled) {
          return;
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var self = debug; // Set `diff` timestamp

        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        } // Apply any `formatters` transformations

        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return match;
          }
          index++;
          var formatter = createDebug.formatters[format];
          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

            args.splice(index, 1);
            index--;
          }
          return match;
        }); // Apply env-specific formatting (colors, etc.)

        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend; // Debug.formatArgs = formatArgs;
      // debug.rawLog = rawLog;
      // env-specific initialization logic for debug instances

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }
      createDebug.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index = createDebug.instances.indexOf(this);
      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace, delimiter) {
      return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    }
    /**
    * Enables a debug mode by namespaces. This can include modes
    * separated by a colon and wildcards.
    *
    * @param {String} namespaces
    * @api public
    */

    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          // ignore empty strings
          continue;
        }
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
      for (i = 0; i < createDebug.instances.length; i++) {
        var instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    /**
    * Disable debug output.
    *
    * @api public
    */

    function disable() {
      createDebug.enable('');
    }
    /**
    * Returns true if the given mode name is enabled, false otherwise.
    *
    * @param {String} name
    * @return {Boolean}
    * @api public
    */

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }
      var i;
      var len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    /**
    * Coerce `val`.
    *
    * @param {Mixed} val
    * @return {Mixed}
    * @api private
    */

    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function (module, exports) {
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof(obj);
    }

    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    /**
     * Colors.
     */

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    // eslint-disable-next-line complexity

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      } // Internet Explorer and Edge do not support colors.

      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      } // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632

      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
      // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }
        index++;
        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      var _console;

      // This hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.getItem('debug');
      } catch (error) {} // Swallow
      // XXX (@Qix-) should we be logging these?
      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG

      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    module.exports = requireCommon()(exports);
    var formatters = module.exports.formatters;
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = {
  exports: {}
};
var hasFlag$1 = function (flag) {
  let argv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.argv;
  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf('--');
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
const os = require$$0__default$5["default"];
const tty = require$$0__default$4["default"];
const hasFlag = hasFlag$1;
const {
  env
} = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
  forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
  forceColor = 1;
}
if ('FORCE_COLOR' in env) {
  if (env.FORCE_COLOR === 'true') {
    forceColor = 1;
  } else if (env.FORCE_COLOR === 'false') {
    forceColor = 0;
  } else {
    forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function supportsColor(haveStream, streamIsTTY) {
  if (forceColor === 0) {
    return 0;
  }
  if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
    return 3;
  }
  if (hasFlag('color=256')) {
    return 2;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === 'dumb') {
    return min;
  }
  if (process.platform === 'win32') {
    // Windows 10 build 10586 is the first Windows release that supports 256 colors.
    // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
    const osRelease = os.release().split('.');
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ('CI' in env) {
    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
      return 1;
    }
    return min;
  }
  if ('TEAMCITY_VERSION' in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === 'truecolor') {
    return 3;
  }
  if ('TERM_PROGRAM' in env) {
    const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Apple_Terminal':
        return 2;
      // No default
    }
  }

  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ('COLORTERM' in env) {
    return 1;
  }
  return min;
}
function getSupportLevel(stream) {
  const level = supportsColor(stream, stream && stream.isTTY);
  return translateLevel(level);
}
var supportsColor_1 = {
  supportsColor: getSupportLevel,
  stdout: translateLevel(supportsColor(true, tty.isatty(1))),
  stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function (module, exports) {
    /**
     * Module dependencies.
     */
    var tty = require$$0__default$4["default"];
    var util = require$$0__default["default"];
    /**
     * This is the Node.js implementation of `debug()`.
     */

    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
      // eslint-disable-next-line import/no-extraneous-dependencies
      var supportsColor = supportsColor_1;
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
      }
    } catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env).filter(function (key) {
      return /^debug_/i.test(key);
    }).reduce(function (obj, key) {
      // Camel-case
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
        return k.toUpperCase();
      }); // Coerce string value into JS value

      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === 'null') {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var name = this.namespace,
        useColors = this.useColors;
      if (useColors) {
        var c = this.color;
        var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
        var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + ' ' + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return '';
      }
      return new Date().toISOString() + ' ';
    }
    /**
     * Invokes `util.format()` with the specified arguments and writes to stderr.
     */

    function log() {
      return process.stderr.write(util.format.apply(util, arguments) + '\n');
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }
    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports);
    var formatters = module.exports.formatters;
    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
        return str.trim();
      }).join(' ');
    };
    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
(function (module) {
  /**
   * Detect Electron renderer / nwjs process, which is node, but we should
   * treat as a browser.
   */
  if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
    module.exports = requireBrowser();
  } else {
    module.exports = requireNode();
  }
})(src);
var debugIt = /*@__PURE__*/getDefaultExportFromCjs(src.exports);
const debug = debugIt("sanity:cli");
function resolveRootDir(cwd) {
  try {
    return resolveProjectRoot(cwd) || cwd;
  } catch (err) {
    throw new Error("Error occurred trying to resolve project root:\n".concat(err.message));
  }
}
function hasStudioConfig(basePath) {
  const buildConfigs = [fileExists(path__default["default"].join(basePath, "studio.config.js")), fileExists(path__default["default"].join(basePath, "studio.config.ts")), isSanityV2StudioRoot(basePath)];
  return buildConfigs.some(Boolean);
}
function resolveProjectRoot(basePath) {
  let iterations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (hasStudioConfig(basePath)) {
    return basePath;
  }
  const parentDir = path__default["default"].resolve(basePath, "..");
  if (parentDir === basePath || iterations > 30) {
    return false;
  }
  return resolveProjectRoot(parentDir, iterations + 1);
}
function isSanityV2StudioRoot(basePath) {
  try {
    const content = require$$0__default$6["default"].readFileSync(path__default["default"].join(basePath, "sanity.json"), "utf8");
    const sanityJson = JSON.parse(content);
    const isRoot = Boolean(sanityJson == null ? void 0 : sanityJson.root);
    if (isRoot) {
      debug("Found Sanity v2 studio root at %s", basePath);
    }
    return isRoot;
  } catch (err) {
    return false;
  }
}
function fileExists(filePath) {
  return require$$0__default$6["default"].existsSync(filePath);
}
exports.commonjsGlobal = commonjsGlobal;
exports.debug = debug;
exports.eventsource = eventsource;
exports.getAugmentedNamespace = getAugmentedNamespace;
exports.objectAssign = objectAssign;
exports.resolveRootDir = resolveRootDir;
exports.sanityClient = sanityClient;
exports.supportsColor_1 = supportsColor_1;
//# sourceMappingURL=resolveRootDir-34841fb2.js.map
